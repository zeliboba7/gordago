<?xml version="1.0" encoding="utf-8" ?>
<Provider Version="1.1">
	<Indicator Name="Accelerator Oscillator">
		<Function Type="Gordago.StockOptimizer2.Toolbox.AC" MTFunc="iAC(NULL,%TIMEFRAME%,%SHIFT%)"></Function>
	</Indicator>
	<Indicator Name="Accumulation/Distribution">
		<Function Type="Gordago.StockOptimizer2.Toolbox.AD" MTFunc="iAD(NULL,%TIMEFRAME%,%SHIFT%)"></Function>
	</Indicator>
	<Indicator Name="ADX">
		<Function Type="Gordago.StockOptimizer2.Toolbox.PDI" MTFunc="iADX(NULL,%TIMEFRAME%,%period%,%applied_price%,MODE_PLUSDI,%SHIFT%)">
			<Parameter MT="applied_price" GSO="2" Type="Vector" />
			<Parameter MT="period" GSO="3" Type="Integer" />
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.MDI" MTFunc="iADX(NULL,%TIMEFRAME%,%period%,%applied_price%,MODE_MINUSDI,%SHIFT%)">
			<Parameter MT="applied_price" GSO="2" Type="Vector" />
			<Parameter MT="period" GSO="3" Type="Integer" />
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.ADX" MTFunc="iADX(NULL,%TIMEFRAME%,%period%,%applied_price%,MODE_MAIN,%SHIFT%)">
			<Parameter MT="applied_price" GSO="2" Type="Vector" />
			<Parameter MT="period" GSO="3" Type="Integer" />
		</Function>
	</Indicator>
	<Indicator Name="Alligator Oscillator">
		<Function Type="Gordago.StockOptimizer2.Toolbox.ReGator" MTFunc="iAlligator(NULL,%TIMEFRAME%,%jaw_period%,%jaw_shift%,%teeth_period%,%teeth_shift%,0,0,%ma_method%,%applied_price%,MODE_UPPER,%SHIFT%)">
			<Parameter MT="teeth_period" GSO="0" Type="Integer" />
			<Parameter MT="teeth_shift" GSO="1" Type="Integer" />
			<Parameter MT="ma_method" GSO="2" Type="Enum" />
			<Parameter MT="applied_price" GSO="3" Type="Vector" />
			<Parameter MT="jaw_period" GSO="4" Type="Integer" />
			<Parameter MT="jaw_shift" GSO="5" Type="Integer" />
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.Gator" MTFunc="iAlligator(NULL,%TIMEFRAME%,0,0,%teeth_period%,%teeth_shift%,%lips_period%,%lips_shift%,%ma_method%,%applied_price%,MODE_UPPER,%SHIFT%)">
			<Parameter MT="teeth_period" GSO="0" Type="Integer" />
			<Parameter MT="teeth_shift" GSO="1" Type="Integer" />
			<Parameter MT="ma_method" GSO="2" Type="Enum" />
			<Parameter MT="applied_price" GSO="3" Type="Vector" />
			<Parameter MT="lips_period" GSO="4" Type="Integer" />
			<Parameter MT="lips_shift" GSO="5" Type="Integer" />
		</Function>
	</Indicator>
	<Indicator Name="Average True Range">
		<Function Type="Gordago.StockOptimizer2.Toolbox.ATR" MTFunc="iATR(NULL,%TIMEFRAME%,%period%,%SHIFT%)">
			<Parameter MT="period" GSO="3" Type="Integer" />
		</Function>
	</Indicator>
	<Indicator Name="Awesome Oscillator">
		<Function Type="Gordago.StockOptimizer2.Toolbox.AO" MTFunc="iAO(NULL,%TIMEFRAME%,%SHIFT%)"></Function>
	</Indicator>
	<Indicator Name="Bears Power">
		<Function Type="Gordago.StockOptimizer2.Toolbox.BearsPower" MTFunc="iBearsPower(NULL,%TIMEFRAME%,%period%,%applied_price%,%SHIFT%)">
			<Parameter MT="period" GSO="1" Type="Integer" />
			<Parameter MT="applied_price" GSO="3" Type="Vector" />
		</Function>
	</Indicator>
	<Indicator Name="Bulls Power">
		<Function Type="Gordago.StockOptimizer2.Toolbox.BullsPower" MTFunc="iBullsPower(NULL,%TIMEFRAME%,%period%,%applied_price%,%SHIFT%)">
			<Parameter MT="period" GSO="1" Type="Integer" />
			<Parameter MT="applied_price" GSO="3" Type="Vector" />
		</Function>
	</Indicator>
	<Indicator Name="Bill Williams Market Facilitation Index">
		<Function Type="Gordago.StockOptimizer2.Toolbox.BWMFI" MTFunc="iBWMFI(NULL,%TIMEFRAME%,%SHIFT%)"></Function>
	</Indicator>
	<Indicator Name="Bollinger Bands">
		<Function Type="Gordago.StockOptimizer2.Toolbox.TopBB" MTFunc="iBands(NULL,%TIMEFRAME%,%period%,%deviation%,0,%applied_price%,MODE_UPPER,%SHIFT%)">
			<Parameter MT="period" GSO="0" Type="Integer" />
			<Parameter MT="applied_price" GSO="2" Type="Vector" />
			<Parameter MT="deviation" GSO="3" Type="Float" />
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.MiddleBB" MTFunc="iBands(NULL,%TIMEFRAME%,%period%,0,0,%applied_price%,MODE_MAIN,%SHIFT%)">
			<Parameter MT="period" GSO="0" Type="Integer" />
			<Parameter MT="applied_price" GSO="2" Type="Vector" />
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.BottomBB" MTFunc="iBands(NULL,%TIMEFRAME%,%period%,%deviation%,0,%applied_price%,MODE_LOWER,%SHIFT%)">
			<Parameter MT="period" GSO="0" Type="Integer" />
			<Parameter MT="applied_price" GSO="2" Type="Vector" />
			<Parameter MT="deviation" GSO="3" Type="Float" />
		</Function>
	</Indicator>
	<Indicator Name="Commodity Channel Index">
		<Function Type="Gordago.StockOptimizer2.Toolbox.CCI" MTFunc="iCCI(NULL,%TIMEFRAME%,%period%,%applied_price%,%SHIFT%)">
			<Parameter MT="period" GSO="0" Type="Integer" />
			<Parameter MT="applied_price" GSO="1" Type="Vector" />
		</Function>
	</Indicator>
	<Indicator Name="DeMarker">
		<Function Type="Gordago.StockOptimizer2.Toolbox.DeMarker" MTFunc="iDeMarker(NULL,%TIMEFRAME%,%period%,%SHIFT%)">
			<Parameter MT="period" GSO="2" Type="Integer" />
		</Function>
	</Indicator>
	<Indicator Name="Envelope">
		<Function Type="Gordago.StockOptimizer2.Toolbox.TopEnvelope" MTFunc="iEnvelopes(NULL,%TIMEFRAME%,%ma_period%,%ma_method%,0,%applied_price%,%deviation%,MODE_UPPER,%SHIFT%)">
			<Parameter MT="ma_period" GSO="0" Type="Integer" />
			<Parameter MT="ma_method" GSO="1" Type="Enum" />
			<Parameter MT="applied_price" GSO="2" Type="Vector" />
			<Parameter MT="deviation" GSO="3" Type="Float" />
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.MiddleEnvelope" MTFunc="iEnvelopes(NULL,%TIMEFRAME%,%ma_period%,%ma_method%,0,%applied_price%,0,MODE_MAIN,%SHIFT%)">
			<Parameter MT="ma_period" GSO="0" Type="Integer" />
			<Parameter MT="ma_method" GSO="1" Type="Enum" />
			<Parameter MT="applied_price" GSO="2" Type="Vector" />
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.BottomEnvelope" MTFunc="iEnvelopes(NULL,%TIMEFRAME%,%ma_period%,%ma_method%,0,%applied_price%,%deviation%,MODE_LOWER,%SHIFT%)">
			<Parameter MT="ma_period" GSO="0" Type="Integer" />
			<Parameter MT="ma_method" GSO="1" Type="Enum" />
			<Parameter MT="applied_price" GSO="2" Type="Vector" />
			<Parameter MT="deviation" GSO="3" Type="Float" />
		</Function>
	</Indicator>
	<Indicator Name="Force Index">
		<Function Type="Gordago.StockOptimizer2.Toolbox.FI" MTFunc="iForce(NULL,%TIMEFRAME%,%period%,%ma_method%,%applied_price%,%SHIFT%)">
			<Parameter MT="period" GSO="0" Type="Integer" />
			<Parameter MT="ma_method" GSO="1" Type="Enum" />
			<Parameter MT="applied_price" GSO="2" Type="Vector" />
		</Function>
	</Indicator>
	<Indicator Name="Moving Average">
		<Function Type="Gordago.StockOptimizer2.Toolbox.MA" MTFunc="iMA(NULL,%TIMEFRAME%,%period%,0,%ma_method%,%applied_price%,%SHIFT%)">
			<Parameter MT="period" GSO="0" Type="Integer" />
			<Parameter MT="ma_method" GSO="1" Type="Enum" />
			<Parameter MT="applied_price" GSO="2" Type="Vector" />
		</Function>
	</Indicator>
	<Indicator Name="Standart Deviation">
		<Function Type="Gordago.StockOptimizer2.Toolbox.StdDev" MTFunc="iStdDev(NULL,%TIMEFRAME%,%period%,1,0,%applied_price%,%SHIFT%)">
			<Parameter MT="applied_price" GSO="0" Type="Vector" />
			<Parameter MT="period" GSO="1" Type="Integer" />
		</Function>
	</Indicator>
	<Indicator Name="MACD">
		<Function Type="Gordago.StockOptimizer2.Toolbox.BaseMACD" MTFunc="iMACD(NULL,%TIMEFRAME%,%fast_ema_period%,%slow_ema_period%,9,%applied_price%,MODE_MAIN,%SHIFT%)">
			<Parameter MT="fast_ema_period" GSO="0" Type="Integer" />
			<Parameter MT="slow_ema_period" GSO="1" Type="Integer" />
			<Parameter MT="applied_price" GSO="3" Type="Vector" />
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.SignalMACD" MTFunc="iMACD(NULL,%TIMEFRAME%,%fast_ema_period%,%slow_ema_period%,%signal_period%,%applied_price%,MODE_SIGNAL,%SHIFT%)">
			<Parameter MT="fast_ema_period" GSO="0" Type="Integer" />
			<Parameter MT="slow_ema_period" GSO="1" Type="Integer" />
			<Parameter MT="applied_price" GSO="3" Type="Vector" />
			<Parameter MT="signal_period" GSO="4" Type="Integer" />
		</Function>
	</Indicator>
	<Indicator Name="Moving Average of Oscillator">
		<Function Type="Gordago.StockOptimizer2.Toolbox.MAO" MTFunc="iOsMA(NULL,%TIMEFRAME%,%fast_ema_period%,%slow_ema_period%,%signal_period%,%applied_price%,%SHIFT%)">
			<Parameter MT="fast_ema_period" GSO="0" Type="Integer" />
			<Parameter MT="slow_ema_period" GSO="1" Type="Integer" />
			<Parameter MT="signal_period" GSO="2" Type="Integer" />
			<Parameter MT="applied_price" GSO="4" Type="Vector" />
		</Function>
	</Indicator>
	<Indicator Name="Money Flow Index">
		<Function Type="Gordago.StockOptimizer2.Toolbox.MFI" MTFunc="iMFI(NULL,%TIMEFRAME%,%period%,%SHIFT%)">
			<Parameter MT="period" GSO="0" Type="Integer" />
		</Function>
	</Indicator>
	<Indicator Name="Momentum">
		<Function Type="Gordago.StockOptimizer2.Toolbox.Momentum" MTFunc="iMomentum(NULL,%TIMEFRAME%,%period%,%applied_price%,%SHIFT%)">
			<Parameter MT="applied_price" GSO="0" Type="Vector" />
			<Parameter MT="period" GSO="1" Type="Integer" />
		</Function>
	</Indicator>
	<Indicator Name="On Balance Volume">
		<Function Type="Gordago.StockOptimizer2.Toolbox.OBV" MTFunc="iOBV(NULL,%TIMEFRAME%,%applied_price%,%SHIFT%)">
			<Parameter MT="applied_price" GSO="0" Type="Vector" />
		</Function>
	</Indicator>
	<Indicator Name="Parabolic SAR">
		<Function Type="Gordago.StockOptimizer2.Toolbox.ParabolicSAR" MTFunc="iSAR(NULL,%TIMEFRAME%,%step%,%maximum%,%SHIFT%)">
			<Parameter MT="step" GSO="2" Type="Float" />
			<Parameter MT="maximum" GSO="3" Type="Float" />
		</Function>
	</Indicator>
	<Indicator Name="Relative Strength Index">
		<Function Type="Gordago.StockOptimizer2.Toolbox.RSI" MTFunc="iRSI(NULL,%TIMEFRAME%,%period%,%applied_price%,%SHIFT%)">
			<Parameter MT="period" GSO="0" Type="Integer" />
			<Parameter MT="applied_price" GSO="1" Type="Vector" />
		</Function>
	</Indicator>
	<Indicator Name="Relative Vigor Index">
		<Function Type="Gordago.StockOptimizer2.Toolbox.BaseRVI" MTFunc="iRVI(NULL,%TIMEFRAME%,%period%,MODE_MAIN,%SHIFT%)">
			<Parameter MT="period" GSO="4" Type="Integer" />
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.SignalRVI" MTFunc="iRVI(NULL,%TIMEFRAME%,%period%,MODE_SIGNAL,%SHIFT%)">
			<Parameter MT="period" GSO="4" Type="Integer" />
		</Function>
	</Indicator>
	<Indicator Name="Stohastic">
		<Function Type="Gordago.StockOptimizer2.Toolbox.K" MTFunc="iStochastic(NULL,%TIMEFRAME%,%Kperiod%,3,%slowing%,%method%,%price_field%,MODE_MAIN,%SHIFT%)">
			<Parameter MT="price_field" GSO="2" Type="Vector" />
			<Parameter MT="Kperiod" GSO="3" Type="Integer" />
			<Parameter MT="method" GSO="4" Type="Enum" />
			<Parameter MT="slowing" GSO="5" Type="Integer" />
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.D" MTFunc="iStochastic(NULL,%TIMEFRAME%,%Kperiod%,%Dperiod%,%slowing%,%method%,%price_field%,MODE_SIGNAL,%SHIFT%)">
			<Parameter MT="price_field" GSO="2" Type="Vector" />
			<Parameter MT="Kperiod" GSO="3" Type="Integer" />
			<Parameter MT="method" GSO="4" Type="Enum" />
			<Parameter MT="slowing" GSO="5" Type="Integer" />
			<Parameter MT="Dperiod" GSO="6" Type="Integer" />
		</Function>
	</Indicator>
	<Indicator Name="Williams Percent Range">
		<Function Type="Gordago.StockOptimizer2.Toolbox.WPR" MTFunc="iWPR(NULL,%TIMEFRAME%,%period%,%SHIFT%)">
			<Parameter MT="period" GSO="3" Type="Integer" />
		</Function>
	</Indicator>
	<Indicator Name="Open">
		<Function Type="Gordago.Analysis.Kernel.Open" MTFunc="iOpen(NULL,%TIMEFRAME%,%SHIFT%)" />
	</Indicator>
	<Indicator Name="Low">
		<Function Type="Gordago.Analysis.Kernel.Low" MTFunc="iLow(NULL,%TIMEFRAME%,%SHIFT%)" />
	</Indicator>
	<Indicator Name="High">
		<Function Type="Gordago.Analysis.Kernel.High" MTFunc="iHigh(NULL,%TIMEFRAME%,%SHIFT%)" />
	</Indicator>
	<Indicator Name="Close">
		<Function Type="Gordago.Analysis.Kernel.Close" MTFunc="iClose(NULL,%TIMEFRAME%,%SHIFT%)" />
	</Indicator>
	<Indicator Name="Median (HL/2)">
		<Function Type="Gordago.Analysis.Kernel.Median" MTFunc="((iHigh(NULL,%TIMEFRAME%,%SHIFT%)+iLow(NULL,%TIMEFRAME%,%SHIFT%))/2)" />
	</Indicator>
	<Indicator Name="Typical (HLC/3)">
		<Function Type="Gordago.Analysis.Kernel.Typical" MTFunc="((iHigh(NULL,%TIMEFRAME%,%SHIFT%)+iLow(NULL,%TIMEFRAME%,%SHIFT%)+iClose(NULL,%TIMEFRAME%,%SHIFT%))/3)" />
	</Indicator>
	<Indicator Name="Weighted (HLCC/4)">
		<Function Type="Gordago.Analysis.Kernel.Weighted" MTFunc="((iHigh(NULL,%TIMEFRAME%,%SHIFT%)+iLow(NULL,%TIMEFRAME%,%SHIFT%)+iClose(NULL,%TIMEFRAME%,%SHIFT%)+iClose(NULL,%TIMEFRAME%,%SHIFT%))/4)" />
	</Indicator>
	<Indicator Name="Volume">
		<Function Type="Gordago.Analysis.Kernel.Volume" MTFunc="iVolume(NULL,%TIMEFRAME%,%SHIFT%)" />
	</Indicator>
	<Indicator Name="Number">
		<Function Type="Gordago.Analysis.Kernel.Number" MTFunc="(%number%)">
			<Parameter MT="number" GSO="0" Type="Integer" />
		</Function>
	</Indicator>
		<Indicator Name="Ichimoku">
		<Function Type="Gordago.StockOptimizer2.Toolbox.IchimokuTenkan" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;Ichimoku&quot;, %Tenkan%, %Kijun%, %Senkou%, 0, %SHIFT%)" FuncRetType="double">
			<Parameter MT="Tenkan" GSO="0" Type="Integer"/>
			<Parameter MT="Kijun" GSO="1" Type="Integer"/>
			<Parameter MT="Senkou" GSO="2" Type="Integer"/>
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.IchimokuKijun" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;Ichimoku&quot;, %Tenkan%, %Kijun%, %Senkou%, 1, %SHIFT%)" FuncRetType="double">
			<Parameter MT="Tenkan" GSO="0" Type="Integer"/>
			<Parameter MT="Kijun" GSO="1" Type="Integer"/>
			<Parameter MT="Senkou" GSO="2" Type="Integer"/>
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.IchimokuSpanA" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;Ichimoku&quot;, %Tenkan%, %Kijun%, %Senkou%, 2, %SHIFT%)" FuncRetType="double">
			<Parameter MT="Tenkan" GSO="0" Type="Integer"/>
			<Parameter MT="Kijun" GSO="1" Type="Integer"/>
			<Parameter MT="Senkou" GSO="2" Type="Integer"/>
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.IchimokuSpanB" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;Ichimoku&quot;, %Tenkan%, %Kijun%, %Senkou%, 3, %SHIFT%)" FuncRetType="double">
			<Parameter MT="Tenkan" GSO="0" Type="Integer"/>
			<Parameter MT="Kijun" GSO="1" Type="Integer"/>
			<Parameter MT="Senkou" GSO="2" Type="Integer"/>
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.IchimokuChinkou" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;Ichimoku&quot;, %Tenkan%, %Kijun%, %Senkou%, 4, %SHIFT%)" FuncRetType="double">
			<Parameter MT="Tenkan" GSO="0" Type="Integer"/>
			<Parameter MT="Kijun" GSO="1" Type="Integer"/>
			<Parameter MT="Senkou" GSO="2" Type="Integer"/>
		</Function>
		<DefIndicator>
//+------------------------------------------------------------------+
//|                                                     Ichimoku.mq4 |
//|                      Copyright © 2004, MetaQuotes Software Corp. |
//|                                       http://www.metaquotes.net/ |
//+------------------------------------------------------------------+
#property copyright "Copyright © 2004, MetaQuotes Software Corp."
#property link      "http://www.metaquotes.net/"

#property indicator_chart_window
#property indicator_buffers 7
#property indicator_color1 Red
#property indicator_color2 Blue
#property indicator_color3 SandyBrown
#property indicator_color4 Thistle
#property indicator_color5 Lime
#property indicator_color6 SandyBrown
#property indicator_color7 Thistle
//---- input parameters
extern int Tenkan=9;
extern int Kijun=26;
extern int Senkou=52;
//---- buffers
double Tenkan_Buffer[];
double Kijun_Buffer[];
double SpanA_Buffer[];
double SpanB_Buffer[];
double Chinkou_Buffer[];
double SpanA2_Buffer[];
double SpanB2_Buffer[];
//----
int a_begin;
//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int init()
  {
//----
   SetIndexStyle(0,DRAW_LINE);
   SetIndexBuffer(0,Tenkan_Buffer);
   SetIndexDrawBegin(0,Tenkan-1);
   SetIndexLabel(0,"Tenkan Sen");
//----
   SetIndexStyle(1,DRAW_LINE);
   SetIndexBuffer(1,Kijun_Buffer);
   SetIndexDrawBegin(1,Kijun-1);
   SetIndexLabel(1,"Kijun Sen");
//----
   a_begin=Kijun; if(a_begin&lt;Tenkan) a_begin=Tenkan;
   SetIndexStyle(2,DRAW_HISTOGRAM,STYLE_DOT);
   SetIndexBuffer(2,SpanA_Buffer);
   SetIndexDrawBegin(2,Kijun+a_begin-1);
   SetIndexShift(2,Kijun);
   SetIndexLabel(2,NULL);
   SetIndexStyle(5,DRAW_LINE,STYLE_DOT);
   SetIndexBuffer(5,SpanA2_Buffer);
   SetIndexDrawBegin(5,Kijun+a_begin-1);
   SetIndexShift(5,Kijun);
   SetIndexLabel(5,"Senkou Span A");
//----
   SetIndexStyle(3,DRAW_HISTOGRAM,STYLE_DOT);
   SetIndexBuffer(3,SpanB_Buffer);
   SetIndexDrawBegin(3,Kijun+Senkou-1);
   SetIndexShift(3,Kijun);
   SetIndexLabel(3,NULL);
   SetIndexStyle(6,DRAW_LINE,STYLE_DOT);
   SetIndexBuffer(6,SpanB2_Buffer);
   SetIndexDrawBegin(6,Kijun+Senkou-1);
   SetIndexShift(6,Kijun);
   SetIndexLabel(6,"Senkou Span B");
//----
   SetIndexStyle(4,DRAW_LINE);
   SetIndexBuffer(4,Chinkou_Buffer);
   SetIndexShift(4,-Kijun);
   SetIndexLabel(4,"Chinkou Span");
//----
   return(0);
  }
//+------------------------------------------------------------------+
//| Ichimoku Kinko Hyo                                               |
//+------------------------------------------------------------------+
int start()
  {
   int    i,k;
   int    counted_bars=IndicatorCounted();
   double high,low,price;
//----
   if(Bars&lt;=Tenkan || Bars&lt;=Kijun || Bars&lt;=Senkou) return(0);
//---- initial zero
   if(counted_bars&lt;1)
     {
      for(i=1;i&lt;=Tenkan;i++)    Tenkan_Buffer[Bars-i]=0;
      for(i=1;i&lt;=Kijun;i++)     Kijun_Buffer[Bars-i]=0;
      for(i=1;i&lt;=a_begin;i++) { SpanA_Buffer[Bars-i]=0; SpanA2_Buffer[Bars-i]=0; }
      for(i=1;i&lt;=Senkou;i++)  { SpanB_Buffer[Bars-i]=0; SpanB2_Buffer[Bars-i]=0; }
     }
//---- Tenkan Sen
   i=Bars-Tenkan;
   if(counted_bars&gt;Tenkan) i=Bars-counted_bars-1;
   while(i&gt;=0)
     {
      high=High[i]; low=Low[i]; k=i-1+Tenkan;
      while(k&gt;=i)
        {
         price=High[k];
         if(high&lt;price) high=price;
         price=Low[k];
         if(low&gt;price)  low=price;
         k--;
        }
      Tenkan_Buffer[i]=(high+low)/2;
      i--;
     }
//---- Kijun Sen
   i=Bars-Kijun;
   if(counted_bars&gt;Kijun) i=Bars-counted_bars-1;
   while(i&gt;=0)
     {
      high=High[i]; low=Low[i]; k=i-1+Kijun;
      while(k&gt;=i)
        {
         price=High[k];
         if(high&lt;price) high=price;
         price=Low[k];
         if(low&gt;price)  low=price;
         k--;
        }
      Kijun_Buffer[i]=(high+low)/2;
      i--;
     }
//---- Senkou Span A
   i=Bars-a_begin+1;
   if(counted_bars&gt;a_begin-1) i=Bars-counted_bars-1;
   while(i&gt;=0)
     {
      price=(Kijun_Buffer[i]+Tenkan_Buffer[i])/2;
      SpanA_Buffer[i]=price;
      SpanA2_Buffer[i]=price;
      i--;
     }
//---- Senkou Span B
   i=Bars-Senkou;
   if(counted_bars&gt;Senkou) i=Bars-counted_bars-1;
   while(i&gt;=0)
     {
      high=High[i]; low=Low[i]; k=i-1+Senkou;
      while(k&gt;=i)
        {
         price=High[k];
         if(high&lt;price) high=price;
         price=Low[k];
         if(low&gt;price)  low=price;
         k--;
        }
      price=(high+low)/2;
      SpanB_Buffer[i]=price;
      SpanB2_Buffer[i]=price;
      i--;
     }
//---- Chinkou Span
   i=Bars-1;
   if(counted_bars&gt;1) i=Bars-counted_bars-1;
   while(i&gt;=0) { Chinkou_Buffer[i]=Close[i]; i--; }
//----
   return(0);
  }
//+------------------------------------------------------------------+
		</DefIndicator>
	</Indicator>
	<Indicator Name="ForecastOscillator">
		<Function Type="Gordago.StockOptimizer2.Toolbox.ForecastOscillatorOsc" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;ForecastOscillator&quot;, %regress%, %t3%, %b%, 0, %SHIFT%)" FuncRetType="double">
			<Parameter MT="regress" GSO="0" Type="Integer"/>
			<Parameter MT="t3" GSO="1" Type="Integer"/>
			<Parameter MT="b" GSO="2" Type="Integer"/>
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.ForecastOscillatorOsct3" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;ForecastOscillator&quot;, %regress%, %t3%, %b%, 1, %SHIFT%)" FuncRetType="double">
			<Parameter MT="regress" GSO="0" Type="Integer"/>
			<Parameter MT="t3" GSO="1" Type="Integer"/>
			<Parameter MT="b" GSO="2" Type="Integer"/>
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.ForecastOscillatorHiSig" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;ForecastOscillator&quot;, %regress%, %t3%, %b%, 2, %SHIFT%)" FuncRetType="double">
			<Parameter MT="regress" GSO="0" Type="Integer"/>
			<Parameter MT="t3" GSO="1" Type="Integer"/>
			<Parameter MT="b" GSO="2" Type="Integer"/>
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.ForecastOscillatorLoSig" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;ForecastOscillator&quot;, %regress%, %t3%, %b%, 3, %SHIFT%)" FuncRetType="double">
			<Parameter MT="regress" GSO="0" Type="Integer"/>
			<Parameter MT="t3" GSO="1" Type="Integer"/>
			<Parameter MT="b" GSO="2" Type="Integer"/>
		</Function>
		<DefIndicator>
//+------------------------------------------------------------------+
//|                                          Forecast Oscillator.mq4 |
//|                Copyright © 2005, Nick Bilak, beluck[AT]gmail.com |
//|                                    http://forexsystems.ru/phpBB/ |
//+------------------------------------------------------------------+
#property copyright "Copyright © 2005, Nick Bilak, beluck[AT]gmail.com"
#property link      "http://forexsystems.ru/phpBB/index.php"

#property indicator_separate_window
#property indicator_buffers 4
#property indicator_level1 0
#property indicator_color1 DarkTurquoise
#property indicator_color2 LawnGreen
#property indicator_color3 Magenta
#property indicator_color4 Aqua
//---- input parameters
extern int       regress=15;
extern int       t3=10;
extern double    b=0.7;
//---- buffers
double osc[];
double osct3[];
double hiSig[];
double loSig[];

int shift,limit,length;
double b2,b3,c1,c2,c3,c4,w1,w2,n,WT,forecastosc,t3_fosc,sum,e1,e2,e3,e4,e5,e6,tmp,tmp2;

//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int init()
  {
//---- indicators
   SetIndexStyle(0,DRAW_LINE);
   SetIndexBuffer(0,osc);
   SetIndexEmptyValue(0,0);
   SetIndexStyle(1,DRAW_LINE);
   SetIndexBuffer(1,osct3);

   SetIndexStyle(2,DRAW_ARROW);
   SetIndexBuffer(2,hiSig);
   SetIndexEmptyValue(2,EMPTY_VALUE);
   SetIndexArrow(2,159);
   SetIndexStyle(3,DRAW_ARROW);
   SetIndexBuffer(3,loSig);
   SetIndexEmptyValue(3,EMPTY_VALUE);
   SetIndexArrow(3,159);
//----
   return(0);
  }
//+------------------------------------------------------------------+
//| Custor indicator deinitialization function                       |
//+------------------------------------------------------------------+
int deinit()
  {
   return(0);
  }
//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int start()
  {
   int counted_bars=IndicatorCounted();
   
   if (counted_bars&lt;0) return(-1);
   if (counted_bars&gt;0) counted_bars--;
   limit=Bars-31;
   if(counted_bars&gt;=31) limit=Bars-counted_bars+2;

   for (shift=limit+30;shift&gt;=0;shift--)   {

      b2=b*b; 
      b3=b2*b; 
      c1=-b3; 
      c2=(3*(b2+b3)); 
      c3=-3*(2*b2+b+b3); 
      c4=(1+3*b+b3+3*b2); 
      n=t3; 

      if (n&lt;1) n=1; 
      n = 1 + 0.5*(n-1); 
      w1 = 2 / (n + 1); 
      w2 = 1 - w1; 

      length=regress; 
      sum = 0; 
      for (int i = length; i&gt;0; i--) {
         tmp = length+1;
         tmp = tmp/3;
         tmp2 = i;
         tmp = tmp2 - tmp;
         sum = sum + tmp*Close[shift+length-i]; 
      }
      tmp = length;
      WT = sum*6/(tmp*(tmp+1)); 

      forecastosc=(Close[shift]-WT)/WT*100; 

      e1 = w1*forecastosc + w2*e1; 
      e2 = w1*e1 + w2*e2; 
      e3 = w1*e2 + w2*e3; 
      e4 = w1*e3 + w2*e4; 
      e5 = w1*e4 + w2*e5; 
      e6 = w1*e5 + w2*e6; 

      t3_fosc = c1*e6 + c2*e5 + c3*e4 + c4*e3; 

      osc[shift] = forecastosc;
      osct3[shift] = t3_fosc;
      
      if (osc[shift+1] &gt; osct3[shift+2] &amp;&amp; osc[shift+2] &lt;= osct3[shift+3] &amp;&amp; osct3[shift+1]&lt;0) loSig[shift+1] = t3_fosc-0.05;
      if (osc[shift+1] &lt; osct3[shift+2] &amp;&amp; osc[shift+2] &gt;= osct3[shift+3] &amp;&amp; osct3[shift+1]&gt;0) hiSig[shift+1] = t3_fosc+0.05;

   }
   Comment("WT=",WT);
   return(0);
  }
//+------------------------------------------------------------------+
		</DefIndicator>
	</Indicator>
	<Indicator Name="Fractals">
		<Function Type="Gordago.StockOptimizer2.Toolbox.FractalDown" MTFunc="iFractals(NULL, %TIMEFRAME%, MODE_LOWER, %SHIFT%)"/>
		<Function Type="Gordago.StockOptimizer2.Toolbox.FractalUp" MTFunc="iFractals(NULL, %TIMEFRAME%, MODE_UPPER, %SHIFT%)"/>
	</Indicator>
	
<Indicator Name="Linereg" DrawChart="Main" Icon="i.gif">
	<Function Type="Gordago.StockOptimizer2.Toolbox.Linereg" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;Linereg&quot;, %rperiod%, 0, %SHIFT%)" FuncRetType="double" >
			<Parameter MT="rperiod" GSO="1" Type="Integer" />
	</Function>
	<DefIndicator>
#property indicator_chart_window
#property indicator_buffers 1
#property indicator_color1 Magenta

extern int  RPeriod = 20;

int shift = 0, cnt = 0,loopbegin = 0;
bool first = True;
int prevbars = 0;
double sum =0, WT = 0;
int i = 0;

double val1[];

int init()
{
 SetIndexBuffer(0,val1);
}

int start()
{
   if (RPeriod&lt;1) 
   {
   return(0);
   }
   
   loopbegin=Bars-RPeriod-1;
   for (shift=loopbegin; shift&gt;=0; shift--)
   {
      sum=0;
      for (i=RPeriod; i&gt;=1; i--)
      {
         sum=sum+(i-(RPeriod+1)/3)*Close[RPeriod-i+shift];
      }
      WT = sum*6/(RPeriod*(RPeriod+1));

	   val1[shift] = WT;
	}
}
	</DefIndicator>
</Indicator>
<Indicator Name="Laguerre" DrawChart="New" Icon="i.gif">
	<Function Type="Gordago.StockOptimizer2.Toolbox.Laguerre" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;Laguerre&quot;, %gamma%, 0, %SHIFT%)" FuncRetType="double" >
			<Parameter MT="gamma" GSO="1" Type="Float" />
	</Function>
	<DefIndicator>
//+------------------------------------------------------------------+
//|                                                     Laguerre.mq4 |
//|                                                     Emerald King |
//|                                                                  |
//+------------------------------------------------------------------+
#property copyright "Emerald King"
#property link      "mailto:info@emerald-king.com"

#property indicator_separate_window
#property indicator_color1 Magenta
#property indicator_level2 0.75
#property indicator_level3 0.45
#property indicator_level4 0.15
//---- input parameters
extern double gamma=0.7;
extern int CountBars=300;

double L0 = 0;
double L1 = 0;
double L2 = 0;
double L3 = 0;
double L0A = 0;   
double L1A = 0;
double L2A = 0;
double L3A = 0;
double LRSI = 0;
double CU = 0;
double CD = 0;

double val1[];
//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
      
int init()
  {
//---- indicators
//----
   SetIndexBuffer(0,val1);
   return(0);
  }
//+------------------------------------------------------------------+
//| Custor indicator deinitialization function                       |
//+------------------------------------------------------------------+
int deinit()
  {
//---- TODO: add your code here
   
//----
   return(0);
  }
//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int start()
  {
   if (CountBars&gt;Bars) CountBars=Bars;
   SetIndexDrawBegin(0,Bars-CountBars);
   
   int i;
   int    counted_bars=IndicatorCounted();

   //if(CountBars&lt;=Lookback) return(0);
   //---- initial zero
   //if(counted_bars&lt;1)
   //{
   //   for(i=1;i&lt;=Lookback;i++) val1[CountBars-i]=0.0;
   //}

   i=CountBars-1;
   while(i&gt;=0)
   {
      L0A = L0;
      L1A = L1;
      L2A = L2;
      L3A = L3;
      L0 = (1 - gamma)*Close[i] + gamma*L0A;
      L1 = - gamma *L0 + L0A + gamma *L1A;
      L2 = - gamma *L1 + L1A + gamma *L2A;
      L3 = - gamma *L2 + L2A + gamma *L3A;

      CU = 0;
      CD = 0;
      
      if (L0 &gt;= L1) CU = L0 - L1; else CD = L1 - L0;
      if (L1 &gt;= L2) CU = CU + L1 - L2; else CD = CD + L2 - L1;
      if (L2 &gt;= L3) CU = CU + L2 - L3; else CD = CD + L3 - L2;

      if (CU + CD != 0) LRSI = CU / (CU + CD);
      val1[i] = LRSI;
	  i--;
	}
   return(0);
 }
//+------------------------------------------------------------------+

	</DefIndicator>
</Indicator>

<Indicator Name="JMA">
		<Function Type="Gordago.StockOptimizer2.Toolbox.JMA"  MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;JMA&quot;, %lenght%, %phase%,0, %SHIFT%)" FuncRetType="double">
			<Parameter MT="lenght" GSO="1" Type="Integer" />
			<Parameter MT="phase" GSO="2" Type="Integer" />
		</Function>
	<DefIndicator>
//+------------------------------------------------------------------+
//|                                                          JMA.mq4 |
//|                                             Weld, Jurik Research |
//|                                          weld.torguem.net        |
//+------------------------------------------------------------------+
#property copyright "Weld"
#property link      "weld.torguem.net"
//I'm just intresting in 11 JMA and 8 JMA on 15M charts. No trading 
//activity just alert.

#property indicator_chart_window
#property indicator_buffers 1
#property indicator_color1 Aqua

//---- input parameters
extern int       Length = 14;
// входной параметр от -100000000 до 100000000
extern int       Phase  = 0;

//---- buffers
double JMAValueBuffer [];
double fC0Buffer [];
double fA8Buffer [];
double fC8Buffer [];

//---- temporary buffers
double list[128], ring1[128], ring2[11], buffer[62];

//---- bool flag
bool   initFlag;

//---- integer vars
int    limitValue, startValue, loopParam, loopCriteria;
int    cycleLimit, highLimit, counterA, counterB;

//---- double vars
double cycleDelta, lowDValue, highDValue, absValue, paramA, paramB;
double phaseParam, logParam, JMAValue, series, sValue, sqrtParam, lengthDivider;

//---- temporary int variables
int   s58, s60, s40, s38, s68;

//+------------------------------------------------------------------+
//| JMA initFlagization function                                     |
//+------------------------------------------------------------------+
int init(){
   double   lengthParam;

//---- 3 additional buffers are used for counting.
   IndicatorBuffers(4);

//---- drawing settings
   SetIndexStyle  (0, DRAW_LINE);
   SetIndexDrawBegin(0, 30);

//---- 4 indicator buffers mapping
   SetIndexBuffer (0, JMAValueBuffer);
   SetIndexBuffer (1, fC0Buffer);
   SetIndexBuffer (2, fA8Buffer);
   SetIndexBuffer (3, fC8Buffer); 

//---- initialize one buffer (neccessary)   
   ArrayInitialize (ring2, 0);
   ArrayInitialize (ring1, 0); 
   ArrayInitialize (buffer, 0); 

//---- name for DataWindow and indicator subwindow label
   IndicatorShortName ("JMAValue(" + Length + "," + Phase + ")");
   SetIndexLabel (0, "JMAValue");

//---- initial part
   limitValue = 63; 
   startValue = 64;

//----   
   for (int i = 0; i &lt;= limitValue; i++) list [i] = -1000000; 
   for (i = startValue; i &lt;= 127; i++)   list [i] = 1000000; 

//----
   initFlag  = true;
   if (Length &lt;1.0000000002) lengthParam = 0.0000000001;
   else lengthParam = (Length - 1) / 2.0;

//----   
   if (Phase &lt;-100) phaseParam = 0.5;
   else if (Phase &gt; 100) phaseParam = 2.5;
   else phaseParam = Phase / 100.0 + 1.5;
//----   
   logParam = MathLog (MathSqrt (lengthParam)) / MathLog (2.0);
//----
   if (logParam + 2.0 &lt; 0) logParam = 0;
   else logParam = logParam + 2.0; 
//----
   sqrtParam     = MathSqrt(lengthParam) * logParam; 
   lengthParam   = lengthParam * 0.9; 
   lengthDivider = lengthParam / (lengthParam + 2.0);

//----  
   return;
}

int start()
  {

//---- get already counted bars    
   int counted_bars = IndicatorCounted();

//---- check for possible errors
   if (counted_bars &lt; 0) return (-1);
   int limit = Bars - counted_bars - 1;

//---- main cycle
   for (int shift = limit; shift &gt;= 0; shift--) {
      series = Close [shift];
 
      if (loopParam &lt; 61) { 
         loopParam++; 
         buffer [loopParam] = series; 
      }else
      {
      Alert(loopParam+ "  " + Bars);
      } 
  
      if (loopParam &gt; 30) {
         if (initFlag) { 
            initFlag = false;
             
            int diffFlag = 0; 
            for (int i = 1; i &lt;= 29; i++) { 
               if (buffer [i + 1] != buffer [i]) diffFlag = 1;
            }  
            highLimit = diffFlag * 30;
             
            if (highLimit == 0) paramB = series;
            else paramB = buffer[1];
             
            paramA = paramB; 
            if (highLimit &gt; 29) highLimit = 29; 
         } else 
            highLimit = 0;

//---- big cycle
         for (i = highLimit; i &gt;= 0; i--) { 
               if (i == 0) sValue = series; 
               else sValue = buffer [31 - i]; 
        
               if (MathAbs (sValue - paramA) &gt; MathAbs (sValue - paramB)) 
                  absValue = MathAbs(sValue - paramA); 
               else absValue = MathAbs(sValue - paramB); 
               
               double dValue = absValue + 0.0000000001; //1.0e-10; 
    
               if (counterA &lt;= 1) counterA = 127; else counterA--; 
               if (counterB &lt;= 1) counterB = 10;  else counterB--; 
               if (cycleLimit &lt; 128) cycleLimit++; 
               cycleDelta += (dValue - ring2 [counterB]); 
               ring2 [counterB] = dValue; 
               
               if (cycleLimit &gt; 10) highDValue = 
                 cycleDelta / 10.0; else highDValue = cycleDelta / cycleLimit; 
               
               if (cycleLimit &gt; 127) { 
                   dValue = ring1 [counterA]; 
                   ring1 [counterA] = highDValue; 
                   s68 = 64; s58 = s68; 
                   while (s68 &gt; 1) { 
                       if (list [s58] &lt; dValue) { 
                           s68 = s68 / 2.0; 
                           s58 += s68; 
                       } else 
                       if (list [s58] &lt;= dValue){ 
                           s68 = 1; 
                       } else { 
                           s68 = s68 / 2.0; 
                           s58 -= s68; 
                       }
               } 
            } else {
                  ring1 [counterA] = highDValue; 
                  if ((limitValue + startValue) &gt; 127) {
                      startValue--; 
                      s58 = startValue; 
                  } else {
                      limitValue++; 
                      s58 = limitValue; 
                  }
                  if (limitValue &gt; 96) s38 = 96; 
                  else s38 = limitValue; 
                  if (startValue &lt; 32) s40 = 32; 
                  else s40 = startValue; 
              }
//----              
              s68 = 64; 
              s60 = s68; 
              while (s68 &gt; 1) {
                  if (list [s60] &gt;= highDValue) {
                      if (list [s60 - 1] &lt;= highDValue) {
                          s68 = 1; 
                      }
                      else {
                          s68 = s68 / 2.0; 
                          s60 -= s68; 
                      }
                  }
                  else {
                      s68 = s68 / 2.0; 
                      s60 += s68; 
                  }
                  if ((s60 == 127) &amp;&amp; (highDValue &gt; list[127])) s60 = 128; 
              }
               if (cycleLimit &gt; 127) {
                   if (s58 &gt;= s60) {
                       if (((s38 + 1) &gt; s60) &amp;&amp; ((s40 - 1) &lt; s60)) 
                            lowDValue += highDValue; 
                       else if ((s40 &gt; s60) &amp;&amp; ((s40 - 1) &lt; s58)) 
                            lowDValue += list [s40 - 1]; 
                   }
                   else if (s40 &gt;= s60) {                       
                   if (((s38 + 1) &lt; s60) &amp;&amp; ((s38 + 1) &gt; s58)) 
                                lowDValue += list[s38 + 1]; 
                    }
                   else if ((s38 + 2) &gt; s60) 
                           lowDValue += highDValue; 
                   else if (((s38 + 1) &lt; s60) &amp;&amp; ((s38 + 1) &gt; s58)) 
                           lowDValue += list[s38 + 1]; 
            
                   if (s58 &gt; s60) {
                       if (((s40 - 1) &lt; s58) &amp;&amp; ((s38 + 1) &gt; s58)) 
                           lowDValue -= list [s58]; 
                       else if ((s38 &lt; s58) &amp;&amp; ((s38 + 1) &gt; s60)) 
                           lowDValue -= list[s38]; 
                   }
                   else {
                       if (((s38 + 1) &gt; s58) &amp;&amp; ((s40 - 1) &lt; s58)) 
                           lowDValue -= list [s58]; 
                       else if ((s40 &gt; s58) &amp;&amp; (s40 &lt; s60)) 
                           lowDValue -= list [s40]; 
                   }
               }
               if (s58 &lt;= s60) {
                   if (s58 &gt;= s60) list[s60] = highDValue; else {
                       for (int j = s58 + 1; j &lt;= (s60 - 1); j++) {
                           list [j - 1] = list[j]; 
                       }
                       list [s60 - 1] = highDValue; 
                   }
               } else {
                   for (j = s58 - 1; j &gt;= s60; j--) {
                       list [j + 1] = list [j]; 
                   }
                   list [s60] = highDValue; 
               }
            
               if (cycleLimit &lt;= 127) {
                   lowDValue = 0;  
                   for (j = s40; j &lt;= s38; j++) {
                       lowDValue += list[j]; 
                   }
               }
//----                
               if ((loopCriteria + 1) &gt; 31) loopCriteria = 31; else loopCriteria++; 
               double JMATempValue, sqrtDivider = sqrtParam / (sqrtParam + 1.0);
               
               if (loopCriteria &lt;= 30) {
                   if (sValue - paramA &gt; 0) paramA = sValue; else paramA = sValue - (sValue - paramA) * sqrtDivider; 
                   if (sValue - paramB &lt; 0) paramB = sValue; else paramB = sValue - (sValue - paramB) * sqrtDivider; 
                   JMATempValue = series;
                 
                   if (loopCriteria == 30) { 
                     fC0Buffer [shift] = series;
                     int intPart;
                      
                     if (MathCeil(sqrtParam) &gt;= 1) intPart = MathCeil(sqrtParam); else intPart = 1; 
                     int leftInt = IntPortion (intPart); 
                     if (MathFloor(sqrtParam) &gt;= 1) intPart = MathFloor(sqrtParam); else intPart = 1; 
                     int rightPart = IntPortion (intPart);
                     
                     if (leftInt == rightPart) dValue = 1.0; 
                     else 
                         dValue = (sqrtParam - rightPart) / (leftInt - rightPart);
                 
                     if (rightPart &lt;= 29) int upShift = rightPart; else upShift = 29; 
                     if (leftInt &lt;= 29) int dnShift = leftInt; else dnShift = 29; 
                     fA8Buffer [shift] = (series - buffer [loopParam - upShift]) * (1 - dValue) / rightPart + (series - buffer[loopParam - dnShift]) * dValue / leftInt;
               }
               } else {
                  double powerValue, squareValue;
                  
                  dValue = lowDValue / (s38 - s40 + 1);
                  if (0.5 &lt;= logParam - 2.0) powerValue = logParam - 2.0;
               else powerValue = 0.5;
               
                   if (logParam &gt;= MathPow(absValue/dValue, powerValue)) dValue = MathPow (absValue/dValue, powerValue); else dValue = logParam; 
                   if (dValue &lt; 1) dValue = 1;
                    
                   powerValue = MathPow (sqrtDivider, MathSqrt (dValue)); 
                   if (sValue - paramA &gt; 0) paramA = sValue; else paramA = sValue - (sValue - paramA) * powerValue; 
                   if (sValue - paramB &lt; 0) paramB = sValue; else paramB = sValue - (sValue - paramB) * powerValue; 
              }
         }
// ---- end of big cycle                                 
         if (loopCriteria &gt; 30) {
                JMATempValue = JMAValueBuffer [shift + 1];
            powerValue   = MathPow (lengthDivider, dValue);
            squareValue  = MathPow (powerValue, 2);
                         
                fC0Buffer [shift] = (1 - powerValue) * series + powerValue * fC0Buffer [shift + 1];
            fC8Buffer [shift] = (series - fC0Buffer [shift]) * (1 - lengthDivider) + lengthDivider * fC8Buffer [shift + 1];
            
            fA8Buffer [shift] = (phaseParam * fC8Buffer [shift] + fC0Buffer [shift] - JMATempValue) * 
                                 (powerValue * (-2.0) + squareValue + 1) + squareValue * fA8Buffer [shift + 1];  
            JMATempValue += fA8Buffer [shift]; 
         }
         JMAValue = JMATempValue;
      }
      
      if (loopParam &lt;= 30) 
         JMAValue = 0;
      
      JMAValueBuffer [shift] = JMAValue;
   } 
   return;
}

//+------------------------------------------------------------------+
int IntPortion (double param) {
   if (param &gt; 0) return (MathFloor (param));
   if (param &lt; 0) return (MathCeil (param));
   return (0.0);
}
//+------------------------------------------------------------------+
</DefIndicator>
</Indicator>

	<Indicator Name="iTrend">
		<Function Type="Gordago.StockOptimizer2.Toolbox.iTrendDir" MTFunc="" FuncRetType="double" NoConverted="True">
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.iTrendPow" MTFunc="" FuncRetType="double" NoConverted="True">
		</Function>
	</Indicator>
		<Indicator Name="Aroon_Horn">
		<Function Type="Gordago.StockOptimizer2.Toolbox.AroonHornUp" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;Aroon_Horn&quot;, %Period%, 0, %SHIFT%)" FuncRetType="double">
			<Parameter MT="Period" GSO="0" Type="Integer"/>
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.AroonHornDown" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;Aroon_Horn&quot;, %Period%, 1, %SHIFT%)" FuncRetType="double">
			<Parameter MT="Period" GSO="0" Type="Integer"/>
		</Function>
		<DefIndicator>
//+------------------------------------------------------------------+
//|                                                   AroonHorn.mq4 |
//|                                           Copyright c 2004, Horn |
//+------------------------------------------------------------------+
#property copyright "Copyright c 2004, Horn"
#property link      "mailto:alexander@indus.ru"

#property indicator_separate_window
#property indicator_buffers 2
#property indicator_color1 Blue
#property indicator_color2 Red 

extern int Calculate_Period=10;

double Buffer1[];
double Buffer2[];

//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int init(){
   SetIndexStyle(0,DRAW_LINE,STYLE_SOLID,1);
   SetIndexBuffer(0,Buffer1);
   SetIndexLabel(0,"Aroon Up");
   SetIndexStyle(1,DRAW_LINE,STYLE_SOLID,1);
   SetIndexBuffer(1,Buffer2);
   SetIndexLabel(1,"Aroon Down");
   return(0);
  }
//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int start() {

   double HighestBar,LowestBar,aroonUp,aroonDn;
   for(int shift=Bars-Calculate_Period;shift>=0;shift--){
      HighestBar = Highest(NULL,0,MODE_HIGH,Calculate_Period-1,shift);
      LowestBar = Lowest(NULL,0,MODE_LOW,Calculate_Period-1,shift);
      
      aroonUp = 100 - ((HighestBar - shift) / Calculate_Period) * 100;
      aroonDn = 100 - ((LowestBar - shift) / Calculate_Period) * 100;  
      
      if(aroonUp == 0) { aroonUp = 0.0000001; }
      if(aroonDn == 0) { aroonDn = 0.0000001; }

      Buffer1[shift]=aroonUp;
      Buffer2[shift]=aroonDn;
   }
   return(0);
  }
//+------------------------------------------------------------------+
		</DefIndicator>
	</Indicator>
		<Indicator Name="FATL">
		<Function Type="Gordago.StockOptimizer2.Toolbox.FATL" 
				MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;FATL&quot;, %applied_price%, 0, %SHIFT%)" FuncRetType="double">
			<Parameter MT="applied_price" GSO="0" Type="Integer"/>
		</Function>
		<DefIndicator>
//+------------------------------------------------------------------+
//|                                                         FATL.mq4 |
//|                            Copyright 2005, Gordago Software Ltd. |
//|                                          http://www.gordago.com/ |
//+------------------------------------------------------------------+
#property copyright "Copyright 2005, Gordago Software Ltd."
#property link      "http://www.gordago.com"

#property indicator_chart_window
#property indicator_buffers 1
#property indicator_color1 Violet

double FATLBuffer[];
#define FATLPeriods 39 

double g_FATLKoef[FATLPeriods]=
  { 0.4360409450,    0.3658689069,    0.2460452079,    0.1104506886,   -0.0054034585,
   -0.0760367731,   -0.0933058722,   -0.0670110374,   -0.0190795053,    0.0259609206,
    0.0502044896,    0.0477818607,    0.0249252327,   -0.0047706151,   -0.0272432537,
   -0.0338917071,   -0.0244141482,   -0.0055774838,    0.0128149838,    0.0226522218,
    0.0208778257,    0.0100299086,   -0.0036771622,   -0.0136744850,   -0.0160483392,
   -0.0108597376,   -0.0016060704,    0.0069480557,    0.0110573605,    0.0095711419,
    0.0040444064,   -0.0023824623,   -0.0067093714,   -0.0072003400,   -0.0047717710,
    0.0005541115,    0.0007860160,    0.0130129076,    0.0040364019  };

int init()
  {
   IndicatorBuffers(1);

   SetIndexStyle(0,DRAW_LINE,STYLE_SOLID,2);
   SetIndexBuffer(0, FATLBuffer);
   SetIndexDrawBegin(0,39);
   return(0);
  }
int deinit(){
   return(0);
}
int start()
{
   int    counted_bars=IndicatorCounted();
   int    j,pos;
   double sum1;
   if(counted_bars&lt;0)  return(-1);
   
   for (pos=Bars-counted_bars-1;pos&gt;=0;pos--)
     {
      sum1=0;         
      for(j=0;j&lt;FATLPeriods;j++) 
         sum1+=g_FATLKoef[j]*Close[pos+j];
	   FATLBuffer[pos]=sum1;
     }
   return(0);
}		</DefIndicator>
	</Indicator>
	<Indicator Name="RFTL">
		<Function Type="Gordago.StockOptimizer2.Toolbox.RFTL" 
				MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;RFTL&quot;, %applied_price%, 0, %SHIFT%)" FuncRetType="double">
			<Parameter MT="applied_price" GSO="0" Type="Integer"/>
		</Function>
		<DefIndicator>
//+------------------------------------------------------------------+
//|                                                         RFTL.mq4 |
//|                            Copyright 2005, Gordago Software Ltd. |
//|                                          http://www.gordago.com/ |
//+------------------------------------------------------------------+
#property copyright "Copyright 2005, Gordago Software Ltd."
#property link      "http://www.gordago.com"

#property indicator_chart_window
#property indicator_buffers 1
#property indicator_color1 Aquamarine

double RFTLBuffer[];

#define RFTLPeriods 44  

double g_RFTLKoef[RFTLPeriods]=
 {-0.0025097319, +0.0513007762 , +0.1142800493 , +0.1699342860 , +0.2025269304 ,
  +0.2025269304, +0.1699342860 , +0.1142800493 , +0.0513007762 , -0.0025097319 ,
  -0.0353166244, -0.0433375629 , -0.0311244617 , -0.0088618137 , +0.0120580088 ,
  +0.0233183633, +0.0221931304 , +0.0115769653 , -0.0022157966 , -0.0126536111 ,
  -0.0157416029, -0.0113395830 , -0.0025905610 , +0.0059521459 , +0.0105212252 ,
  +0.0096970755, +0.0046585685 , -0.0017079230 , -0.0063513565 , -0.0074539350 ,
  -0.0050439973, -0.0007459678 , +0.0032271474 , +0.0051357867 , +0.0044454862 ,
  +0.0018784961, -0.0011065767 , -0.0031162862 , -0.0033443253 , -0.0022163335 ,
  +0.0002573669, +0.0003650790 , +0.0060440751 , +0.0018747783 };

int init()
  {
   IndicatorBuffers(1);
   
   SetIndexStyle(0,DRAW_LINE,STYLE_SOLID,2);
   SetIndexBuffer(0, RFTLBuffer);
   SetIndexDrawBegin(0,44);
   
   return(0);
  }
int deinit()
  {
   return(0);
  }
int start()
{
   int    counted_bars=IndicatorCounted();
   int    j,pos;
   double sum2;
   if(counted_bars&lt;0)  return(-1);
   
   for (pos=Bars-counted_bars-1;pos&gt;=0;pos--)
     {
	   sum2=0;          // zero summary
      for(j=0;j&lt;RFTLPeriods;j++) sum2+=g_RFTLKoef[j]*Close[pos+j];//Counted RFTL[pos]
	   RFTLBuffer[pos]=sum2;
     }
   return(0);
}		</DefIndicator>
	</Indicator>
	<Indicator Name="SATL">
		<Function Type="Gordago.StockOptimizer2.Toolbox.SATL" 
				MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;SATL&quot;, %applied_price%, 0, %SHIFT%)" FuncRetType="double">
			<Parameter MT="applied_price" GSO="0" Type="Integer"/>
		</Function>
		<DefIndicator>
//+------------------------------------------------------------------+
//|                                                         SATL.mq4 |
//|                      Copyright © 2004, MetaQuotes Software Corp. |
//|                                        http://www.metaquotes.net |
//+------------------------------------------------------------------+
#property copyright "Copyright © 2004, MetaQuotes Software Corp."
#property link      "http://www.metaquotes.net"

#property indicator_chart_window
#property indicator_buffers 1
#property indicator_color1 Wheat

double SATLBuffer[];

#define SATLPeriods 65 

double g_SATLKoef[SATLPeriods]=
 {0.0982862174 ,+0.0975682269 ,+0.0961401078 ,+0.0940230544 ,+0.0912437090 ,+0.0878391006 ,
 +0.0838544303 ,+0.0793406350 ,+0.0743569346 ,+0.0689666682 ,+0.0632381578 ,+0.0572428925 ,
 +0.0510534242 ,+0.0447468229 ,+0.0383959950 ,+0.0320735368 ,+0.0258537721 ,+0.0198005183 ,
 +0.0139807863 ,+0.0084512448 ,+0.0032639979 ,-0.0015350359 ,-0.0059060082 ,-0.0098190256 ,
 -0.0132507215 ,-0.0161875265 ,-0.0186164872 ,-0.0205446727 ,-0.0219739146 ,-0.0229204861 ,
 -0.0234080863 ,-0.0234566315 ,-0.0231017777 ,-0.0223796900 ,-0.0213300463 ,-0.0199924534 ,
 -0.0184126992 ,-0.0166377699 ,-0.0147139428 ,-0.0126796776 ,-0.0105938331 ,-0.0084736770 ,
 -0.0063841850 ,-0.0043466731 ,-0.0023956944 ,-0.0005535180 ,+0.0011421469 ,+0.0026845693 ,
 +0.0040471369 ,+0.0052380201 ,+0.0062194591 ,+0.0070340085 ,+0.0076266453 ,+0.0080376628 ,
 +0.0083037666 ,+0.0083694798 ,+0.0082901022 ,+0.0080741359 ,+0.0077543820 ,+0.0073260526 ,
 +0.0068163569 ,+0.0062325477 ,+0.0056078229 ,+0.0049516078,+0.0161380976 };

int init()
  {
   IndicatorBuffers(1);
   SetIndexStyle(0,DRAW_LINE,STYLE_SOLID,2);
   SetIndexBuffer(0, SATLBuffer);
   SetIndexDrawBegin(0,65);
   return(0);
  }
int deinit()
   return(0);
  }
int start()
{
   int    counted_bars=IndicatorCounted();
   int    j,pos;
   double sum3;
   if(counted_bars&lt;0)  return(-1);
   for (pos=Bars-counted_bars-1;pos&gt;=0;pos--)
     {
	   sum3=0;          // zero summary
      for(j=0;j&lt;SATLPeriods;j++) sum3+=g_SATLKoef[j]*Close[pos+j];//Counted SATL[POS]
	   SATLBuffer[pos]=sum3;
	  }
   return(0);
}
		</DefIndicator>
	</Indicator>
	<Indicator Name="RSTL">
		<Function Type="Gordago.StockOptimizer2.Toolbox.RSTL" 
				MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;RSTL&quot;, %applied_price%, 0, %SHIFT%)" FuncRetType="double">
			<Parameter MT="applied_price" GSO="0" Type="Integer"/>
		</Function>
		<DefIndicator>
//+------------------------------------------------------------------+
//|                                                         RSTL.mq4 |
//|                      Copyright © 2004, MetaQuotes Software Corp. |
//|                                        http://www.metaquotes.net |
//+------------------------------------------------------------------+
#property copyright "Copyright © 2004, MetaQuotes Software Corp."
#property link      "http://www.metaquotes.net"

#property indicator_chart_window
#property indicator_buffers 1
#property indicator_color1 IndianRed

double RSTLBuffer[];

#define RSTLPeriods 91 

double g_RSTLKoef[RSTLPeriods]=
 {-0.0074151919,-0.0060698985,-0.0044979052,-0.0027054278,-0.0007031702,+0.0014951741,
  +0.0038713513,+0.0064043271,+0.0090702334,+0.0118431116,+0.0146922652,+0.0175884606, 
  +0.0204976517,+0.0233865835,+0.0262218588,+0.0289681736,+0.0315922931,+0.0340614696,
  +0.0363444061,+0.0384120882,+0.0402373884,+0.0417969735,+0.0430701377,+0.0440399188,
  +0.0446941124,+0.0450230100,+0.0450230100,+0.0446941124,+0.0440399188,+0.0430701377,
  +0.0417969735,+0.0402373884,+0.0384120882,+0.0363444061,+0.0340614696,+0.0315922931,
  +0.0289681736,+0.0262218588,+0.0233865835,+0.0204976517,+0.0175884606,+0.0146922652,
  +0.0118431116,+0.0090702334,+0.0064043271,+0.0038713513,+0.0014951741,-0.0007031702,
  -0.0027054278,-0.0044979052,-0.0060698985,-0.0074151919,-0.0085278517,-0.0094111161,
  -0.0100658241,-0.0104994302,-0.0107227904,-0.0107450280,-0.0105824763,-0.0102517019,
  -0.0097708805,-0.0091581551,-0.0084345004,-0.0076214397,-0.0067401718,-0.0058083144,
  -0.0048528295,-0.0038816271,-0.0029244713,-0.0019911267,-0.0010974211,-0.0002535559,
  +0.0005231953,+0.0012297491,+0.0018539149,+0.0023994354,+0.0028490136,+0.0032221429,
  +0.0034936183,+0.0036818974,+0.0038037944,+0.0038338964,+0.0037975350,+0.0036986051,
  +0.0035521320,+0.0033559226,+0.0031224409,+0.0028550092,+0.0025688349,+0.0022682355, 
  +0.0073925495 };

int init()
  {
   IndicatorBuffers(1);

   SetIndexStyle(3,DRAW_LINE,STYLE_SOLID,2);
   SetIndexBuffer(3, RSTLBuffer);
   SetIndexDrawBegin(3,91);

   return(0);
  }
int deinit()
  {
   return(0);
  }
int start()
{
   int    counted_bars=IndicatorCounted();
   int    j,pos;
   double sum4;
   if(counted_bars&lt;0)  return(-1);
   for (pos=Bars-counted_bars-1;pos&gt;=0;pos--)
     {
	   sum4=0;          // zero summary
      for(j=0;j&lt;RSTLPeriods;j++) sum4+=g_RSTLKoef[j]*Close[pos+j];//Counted RSTL[pos]
	   RSTLBuffer[pos]=sum4;
     }
   return(0);
}
		</DefIndicator>
	</Indicator>
		<Indicator Name="HeikinAshiMOD">
		<Function Type="Gordago.StockOptimizer2.Toolbox.HeikinAshiMODF1" 
				MTFunc="iCustom(NULL, 0, &quot;HeikinAshiMOD&quot;, %compbars%, 0, %SHIFT%)" FuncRetType="double">
			<Parameter MT="compbars" GSO="4" Type="Integer"/>
		</Function>
		<Function Type="Gordago.StockOptimizer2.Toolbox.HeikinAshiMODF2"
				MTFunc="iCustom(NULL, 0, &quot;HeikinAshiMOD&quot;, %compbars%, 1, %SHIFT%)" FuncRetType="double">
			<Parameter MT="compbars" GSO="4" Type="Integer"/>
		</Function>
		<DefIndicator>
//+------------------------------------------------------------------+
//|                                              HeikinAshiMOD.mq4 |
//|                                                  tom112@Aborigen |
//|                                            tom112@mail.wplus.net |
//+------------------------------------------------------------------+
#property copyright "tom112@Aborigen"
#property link      "tom112@mail.wplus.net"

#property indicator_chart_window
#property indicator_buffers 2
#property indicator_color1 Blue
#property indicator_color2 Red

extern int CompBars = 8;
extern int NRRASCH = 300;

double haOpen[132000], haClose[132000];
double Buffer1[], Buffer2[];

int init(){
   SetIndexStyle(0, DRAW_HISTOGRAM, STYLE_SOLID, 1);
   SetIndexBuffer(0, Buffer1);

   SetIndexStyle(1, DRAW_HISTOGRAM, STYLE_SOLID, 1);
   SetIndexBuffer(1, Buffer2);
   
   ArrayInitialize(haOpen, 0);
   ArrayInitialize(haClose, 0);
}

//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int start() {
   
   double Value1, Value2, Max1, Max2, Min1, Min2;
      
   for(int curbar = NRRASCH; curbar&gt;=0;curbar--){
      haClose[curbar] = (High[curbar]+ Open[curbar] + Low[curbar] + Close[curbar])/4;
      
      if (curbar == NRRASCH){
         haOpen[curbar+1]=Open[curbar+1]; 
      }
      
      haOpen[curbar] = (haOpen[curbar+1] + haClose[curbar+1])/2;
      
      if (haClose[curbar] &lt; haOpen[curbar]) {
         Value1 = Low[curbar]; 
         Value2 = High[curbar]; 
      }
	
      if (haClose[curbar] &gt; haOpen[curbar]){ 
         Value2 = Low[curbar]; 
         Value1 = High[curbar];
      }
      
      for (int i=CompBars; i&gt;=0; i--){
         Max1=MathMax(haOpen[curbar+i],haClose[curbar+i]);
         Min1=MathMin(haOpen[curbar+i],haClose[curbar+i]);
         
         if ( haOpen[curbar]  &gt;= Min1 &amp;&amp; haOpen[curbar] &lt;= Max1 &amp;&amp;
			     haClose[curbar] &gt;= Min1 &amp;&amp; haClose[curbar] &lt;= Max1){
			   
            if (haClose[curbar+i] &lt; haOpen[curbar+i]){
               Value1 = Low[curbar]; 
               Value2 = High[curbar];
               break;
            }
            if (haClose[curbar+i] &gt; haOpen[curbar+i]) { 
               Value2 = Low[curbar]; 
               Value1 = High[curbar];
               break;
            }
         }
      }
      
      Buffer1[curbar] = Value1;
      Buffer2[curbar] = Value2;
   }
   
   return(0);
}
//+------------------------------------------------------------------+
		</DefIndicator>
	</Indicator>
	<Indicator Name="HMA" DrawChart="Main" Icon="i.gif">
	<Function Type="Gordago.StockOptimizer2.Toolbox.HMA" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;HMA&quot;, %period%, 0, %SHIFT%)" FuncRetType="double" >
			<Parameter MT="period" GSO="1" Type="Integer" />
	</Function>
	<DefIndicator>
//+------------------------------------------------------------------+
//|                                                          HMA.mq4 |
//|                      Copyright c 2004, MetaQuotes Software Corp. |
//|                                       http://www.metaquotes.net/ |
//+------------------------------------------------------------------+
#property  copyright &quot;Copyright © 2004, MetaQuotes Software Corp.&quot;
#property  link      &quot;http://www.metaquotes.net/&quot;
//---- indicator settings
#property  indicator_chart_window
#property  indicator_buffers 1
#property  indicator_color1  Blue
 
//---- indicator parameters
extern int HMA_Period=20;
//---- indicator buffers
double     ind_buffer0[];
double     ind_buffer1[];

int        draw_begin0;

//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int init()
  {
//---- indicator buffers mapping
   IndicatorBuffers(2);
   if(!SetIndexBuffer(0,ind_buffer0) &amp;&amp; !SetIndexBuffer(1,ind_buffer1))
      Print("cannot set indicator buffers!");
//   ArraySetAsSeries(ind_buffer1,true);
//---- drawing settings
   SetIndexStyle(0,DRAW_LINE,STYLE_SOLID,3);
   draw_begin0=HMA_Period+MathFloor(MathSqrt(HMA_Period));
   SetIndexDrawBegin(0,draw_begin0);
   IndicatorDigits(MarketInfo(Symbol(),MODE_DIGITS)+1);
//---- name for DataWindow and indicator subwindow label
   IndicatorShortName("HMA("+HMA_Period+")");
   SetIndexLabel(0,"Hull Moving Average");
//---- initialization done
   return(0);
  }
//+------------------------------------------------------------------+
//| Moving Averages Convergence/Divergence                           |
//+------------------------------------------------------------------+
int start()
  {
   int limit,i;
   int counted_bars=IndicatorCounted();
//---- check for possible errors
   if(counted_bars&lt;1){
      for(i=1;i&lt;=draw_begin0;i++) ind_buffer0[Bars-i]=0;
      for(i=1;i&lt;=HMA_Period;i++) ind_buffer1[Bars-i]=0;
   }
   if(counted_bars&gt;0) counted_bars--;
   limit=Bars-counted_bars;
   for(i=0; i&lt;limit; i++)
      ind_buffer1[i]=iMA(NULL,0,MathFloor(HMA_Period/2),0,MODE_LWMA,PRICE_CLOSE,i)*2-
                     iMA(NULL,0,HMA_Period,0,MODE_LWMA,PRICE_CLOSE,i);
   for(i=0; i&lt;limit; i++)
      ind_buffer0[i]=iMAOnArray(ind_buffer1,0,MathFloor(MathSqrt(HMA_Period)),0,MODE_LWMA,i);

   return(0);
}	
	</DefIndicator>
</Indicator>
<Indicator Name="PeriodOfTime">
	<Function Type="Gordago.Analysis.Toolbox.PeriodOfTime" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;PeriodOfTime&quot;, %hour%, %minute%, %tperiod%, 0, %SHIFT%)" FuncRetType="double" >
			<Parameter MT="hour" GSO="0" Type="Integer" />
			<Parameter MT="minute" GSO="1" Type="Integer" />
			<Parameter MT="tperiod" GSO="2" Type="Integer" />
	</Function>
	<DefIndicator>
//+------------------------------------------------------------------+
//|                                                 PeriodOfTime.mq4 |
//|                          Copyright c 2006, Gordago Software Ltd. |
//|                                           http://www.gordago.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright c 2006, Gordago Software Ltd.&quot;
#property link      &quot;http://www.gordago.com&quot;

#property indicator_chart_window
#property indicator_buffers 1
#property indicator_color1 Magenta
//---- input parameters
extern int       prmHour=12;
extern int       prmMinute=15;
extern int       prmPeriod=3;
//---- buffers
double ExtMapBuffer1[];
//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int init()
  {
//---- indicators
   SetIndexStyle(0,DRAW_ARROW);
   SetIndexArrow(0,251);
   SetIndexBuffer(0,ExtMapBuffer1);
   SetIndexEmptyValue(0,0.0);
//----
   return(0);
  }
//+------------------------------------------------------------------+
//| Custor indicator deinitialization function                       |
//+------------------------------------------------------------------+
int deinit()
  {
//---- 
   
//----
   return(0);
  }
//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int start()
  {
   int    counted_bars=IndicatorCounted();
   if(counted_bars&lt;0) return(-1);
   if(counted_bars&gt;0) counted_bars--;
   int pos=Bars-counted_bars;
   while(pos&gt;=0){
   
      int iYear = TimeYear(Time[pos]);
      int iMonth = TimeMonth(Time[pos]);
      int iDay = TimeDay(Time[pos]);
      int iHour = TimeHour(prmHour);
      int iMinute = TimeMinute(prmMinute);
      string strdtm = iYear + &quot;.&quot; + iMonth + &quot;.&quot; + iDay + &quot; &quot; + prmHour + &quot;:&quot; + prmMinute;
      datetime dtm = StrToTime(strdtm);
      datetime dtmto = dtm + prmPeriod * 60 - 1;
		
		if (Time[pos] &gt;= dtm &amp;&amp; Time[pos] &lt;= dtmto)
   		ExtMapBuffer1[pos] = High[pos]+Point*2;
	   else
         ExtMapBuffer1[pos] = 0.0;
 	   pos--;
   }
   return(0);
  }
//+------------------------------------------------------------------+
	</DefIndicator>
</Indicator>
<Indicator Name="DayOfWeek">
	<Function Type="Gordago.Analysis.Toolbox.__DayOfWeek" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;DayOfWeek&quot;, %week%, 0, %SHIFT%)" FuncRetType="double" >
			<Parameter MT="week" GSO="0" Type="Integer" />
	</Function>
	<DefIndicator>
//+------------------------------------------------------------------+
//|                                                    DayOfWeek.mq4 |
//|                          Copyright c 2006, Gordago Software Ltd. |
//|                                           http://www.gordago.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright c 2006, Gordago Software Ltd.&quot;
#property link      &quot;http://www.gordago.com&quot;

#property indicator_chart_window
#property indicator_buffers 1
#property indicator_color1 SpringGreen
//---- input parameters
extern int       prmWeek=0;
//---- buffers
double ExtMapBuffer1[];
//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int init()
  {
//---- indicators
   SetIndexStyle(0,DRAW_ARROW);
   SetIndexArrow(0,108);
   SetIndexBuffer(0,ExtMapBuffer1);
   SetIndexEmptyValue(0,0.0);
//----
   return(0);
  }
//+------------------------------------------------------------------+
//| Custor indicator deinitialization function                       |
//+------------------------------------------------------------------+
int deinit()
  {
//---- 
   
//----
   return(0);
  }
//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int start()
  {
   int    counted_bars=IndicatorCounted();
   if(counted_bars&lt;0) return(-1);
   if(counted_bars&gt;0) counted_bars--;
   int pos=Bars-counted_bars;
   while(pos&gt;=0){
		if (prmWeek == TimeDayOfWeek(Time[pos]))
   		ExtMapBuffer1[pos] = High[pos]+Point*3;
	   else
         ExtMapBuffer1[pos] = 0.0;
 	   pos--;   
   }
   return(0);
  }
//+------------------------------------------------------------------+
	</DefIndicator>
</Indicator>
<Indicator Name="T3_TrixG">
	<Function Type="Gordago.Analysis.CustomIndicators.Trix" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;T3_Trix&quot;, %AT3Period%, 10, %Hot%, 0, %SHIFT%)" FuncRetType="double" >
			<Parameter MT="AT3Period" GSO="0" Type="Integer" />
			<Parameter MT="Hot" GSO="1" Type="Integer" />
	</Function>
	<Function Type="Gordago.Analysis.CustomIndicators.TrixB" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;T3_Trix&quot;, 18, %BT3Period%, %Hot%, 1, %SHIFT%)" FuncRetType="double" >
			<Parameter MT="BT3Period" GSO="3" Type="Integer" />
			<Parameter MT="Hot" GSO="1" Type="Integer" />
	</Function>
	<DefIndicator>
//+------------------------------------------------------------------+
//|                                                      T3_TRIX.mq4 |
//|                          Copyright c 2006, Gordago Software Ltd. |
//|                                           http://www.gordago.com |
//+------------------------------------------------------------------+
#property copyright &quot;Copyright c 2006, Gordago Software Ltd.&quot;
#property link      &quot;http://www.gordago.com&quot;

#property indicator_separate_window
#property indicator_buffers 2
#property indicator_color1 DeepSkyBlue 
#property indicator_color2 Blue

extern int AT3Period = 18;
extern int BT3PeriodAC = 10;
extern double Hot=0.7;

int _countBars = 350;

double ExtMapBuffer1[];
double ExtMapBuffer2[];

int init() {
   SetIndexStyle(0,DRAW_LINE);
   SetIndexBuffer(0,ExtMapBuffer1);
   SetIndexStyle(1,DRAW_HISTOGRAM);
   SetIndexBuffer(1,ExtMapBuffer2);
   return(0);
}

int deinit() {
   return(0);
}

int start() {

   int  shift=0;
   double A_t3=0, A_t3_1=0, max_per=0;
   double B_t3=0,B_t3_1=0;
   double e1=0,e2=0,e3=0,e4=0,e5=0,e6=0,c1=0,c2=0,c3=0,c4=0;
   double e1x=0,e2x=0,e3x=0,e4x=0,e5x=0,e6x=0;
   double d1=0,d2=0,d3=0,d4=0,d5=0,d6=0;
   double d1x=0,d2x=0,d3x=0,d4x=0,d5x=0,d6x=0;
   double n=0,A_w1=0,A_w2=0,B_w1=0,B_w2=0,b2=0,b3=0;
   bool init=true;
   double bar=0, prevbars=0, start=0, cs=0, prevcs=0,frame=0; 
   int    counted_bars=IndicatorCounted();

   cs = _countBars + AT3Period + BT3PeriodAC +  Hot;

   if (cs==prevcs &amp;&amp; frame==Time[4]-Time[5] &amp;&amp; Bars-prevbars&lt;2)
      start=Bars-prevbars;
   else 
      start=-1;   
   
   frame=Time[4]-Time[5];
   prevbars = Bars;
   prevcs = cs;   
   
   if (start==1 || start==0)  
      bar=start; 
   else 
      init=true;

   if (init==true){
      b2=Hot*Hot;
      b3=b2*Hot;
      c1=-b3;
      c2=(3*(b2+b3));
      c3=-3*(2*b2+Hot+b3);
      c4=(1+3*Hot+b3+3*b2);
 
      n=AT3Period;

      if (n&lt;1) n=1;
 
      n = 1 + 0.5*(n-1);
      A_w1 = 2 / (n + 1);
      A_w2 = 1 - A_w1;

      n = BT3PeriodAC;

      if (n&lt;1) n=1;
      n = 1 + 0.5*(n-1);
      B_w1 = 2 / (n + 1);
      B_w2 = 1 - B_w1;

      ExtMapBuffer1[_countBars-1]=0;

      e1x=0;e2x=0;e3x=0;e4x=0;e5x=0;e6x=0;

      ExtMapBuffer2[_countBars-1]=0;

      d1x=0;d2x=0;d3x=0;d4x=0;d5x=0;d6x=0;

      bar=_countBars-2;
      init=false;
   }

   shift=bar;

   while(shift&gt;=0){

      d1 = A_w1*Close[shift] + A_w2*d1x;
         
      d2 = A_w1*d1 + A_w2*d2x;
      d3 = A_w1*d2 + A_w2*d3x;
      d4 = A_w1*d3 + A_w2*d4x;
      d5 = A_w1*d4 + A_w2*d5x;
      d6 = A_w1*d5 + A_w2*d6x;

      A_t3 = c1*d6 + c2*d5 + c3*d4 + c4*d3;
 
      if ((start==1 &amp;&amp; shift==1) || start==-1  ){ 
         d1x=d1; d2x=d2; d3x=d3; d4x=d4; d5x=d5; d6x=d6;
      }
      e1 = B_w1*Close[shift] + B_w2*e1x;
      e2 = B_w1*e1 + B_w2*e2x;
      e3 = B_w1*e2 + B_w2*e3x;
      e4 = B_w1*e3 + B_w2*e4x;
      e5 = B_w1*e4 + B_w2*e5x;
      e6 = B_w1*e5 + B_w2*e6x;
      B_t3 = c1*e6 + c2*e5 + c3*e4 + c4*e3;

      if ( B_t3_1 &gt;0 &amp;&amp; A_t3_1&gt;0) {
         ExtMapBuffer1[shift]=(A_t3-A_t3_1)/A_t3_1;
         ExtMapBuffer2[shift]=(B_t3-B_t3_1)/B_t3_1;
      }
      if ((start==1 &amp;&amp; shift==1) || start==-1) { 
         A_t3_1=A_t3;
         B_t3_1=B_t3;
         e1x=e1; e2x=e2; e3x=e3; e4x=e4; e5x=e5; e6x=e6;
      }
      shift--;
   }
}
	</DefIndicator>
</Indicator>
<Indicator Name="TriggerLine">
	<Function Type="Gordago.Analysis.Toolbox.TriggerLineSell" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;TriggerLine&quot;, %RPeriod%, %LSMA_Period%, 0, %SHIFT%)" FuncRetType="double" >
			<Parameter MT="RPeriod" GSO="0" Type="Integer" />
			<Parameter MT="LSMA_Period" GSO="1" Type="Integer" />
	</Function>
	<Function Type="Gordago.Analysis.Toolbox.TriggerLineBuy" MTFunc="iCustom(NULL, %TIMEFRAME%, &quot;TriggerLine&quot;, %RPeriod%, %LSMA_Period%, 0, %SHIFT%)" FuncRetType="double" >
			<Parameter MT="RPeriod" GSO="0" Type="Integer" />
			<Parameter MT="LSMA_Period" GSO="1" Type="Integer" />
	</Function>
	<DefIndicator>
//+------------------------------------------------------------------+
//|                                                     Trigger Line |
//|                           Copyright c 2006 Gordago Software Ltd. |
//|                                          http://www.gordago.com/ |
//+------------------------------------------------------------------+
#property  copyright &quot;Copyright c 2006 Gordago Software Ltd.&quot;
#property  link      &quot;http://www.gordago.com/&quot;

#property indicator_separate_window
#property indicator_buffers 4            
#property indicator_color1 Red      
#property indicator_color2 Blue

extern int RPeriod = 30;
extern int LSMA_Period = 5;

double ExtMapBuffer1[];
double ExtMapBuffer2[];

double wt[];
double lsma_ma[];

int init(){ 
   IndicatorBuffers(5);   
   
   SetIndexBuffer(0,ExtMapBuffer1);
   SetIndexStyle(0,DRAW_ARROW,EMPTY);
   SetIndexArrow(0,108);
   
   SetIndexBuffer(1,ExtMapBuffer2);
   SetIndexStyle(1,DRAW_ARROW,EMPTY);
   SetIndexArrow(1,108);

   SetIndexBuffer(2,wt);         
   SetIndexBuffer(3,lsma_ma);

   return(0);
}

int start(){

   int shift, i;

   int loopbegin = Bars - RPeriod - 1;
   int koef = (RPeriod + 1)/3;
   
   for(shift = loopbegin; shift &gt;= 0; shift--){ 
      double sum = 0;                                              
      for(i = RPeriod; i &gt;= 1; i--){
         sum += (i - koef)*Close[shift+RPeriod-i];
      }
      
      wt[shift] = sum*6/(RPeriod*(RPeriod+1));  
      lsma_ma[shift] = wt[shift+1] + (wt[shift]-wt[shift+1])* 2/(LSMA_Period+1);
      
      double valline = (wt[shift]+lsma_ma[shift])/2;

      if (wt[shift] &lt; lsma_ma[shift]){
         ExtMapBuffer1[shift] = valline;
      }else if (wt[shift] &gt; lsma_ma[shift]){
         ExtMapBuffer2[shift] = valline; 
      }
   }
}
	</DefIndicator>
</Indicator>

</Provider>